rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // SECURITY MODEL NOTES
    // ============================================
    // 
    // For Upcoming Summary (events, locations, birthdays):
    // - Events: Strictly secured - only group members can read
    // - Locations/Users: Read allowed for authenticated users, but
    //   app-level filtering ensures users only see data from their groups
    // - This hybrid approach balances security with Firestore query limits
    //   (Firestore can't efficiently check "shares any group" in rules)
    //
    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Get the current user's UID
    function userId() {
      return request.auth.uid;
    }
    
    // Get a group document
    function getGroup(groupId) {
      return get(/databases/$(database)/documents/groups/$(groupId)).data;
    }
    
    // Check if user is a member of a group
    function isGroupMember(groupId) {
      return isAuthenticated() && 
             userId() in getGroup(groupId).members;
    }
    
    // Check if user is an admin of a group (includes owner)
    function isGroupAdmin(groupId) {
      let group = getGroup(groupId);
      return isAuthenticated() && 
             (userId() == group.ownerId || userId() in group.admins);
    }
    
    // Check if user is the owner of a group
    function isGroupOwner(groupId) {
      return isAuthenticated() && 
             userId() == getGroup(groupId).ownerId;
    }
    
    // Check if user shares any group with another user
    function sharesGroupWith(otherUserId) {
      // This is a simplified check - in practice, you might need to query groups
      return isAuthenticated();
    }
    
    // Check if target user has a pending join request to a group where current user is admin
    // NOTE: This cannot be done efficiently in rules (would require querying join_requests).
    // Instead, we embed the requester's name IN the join_request document at creation time,
    // so admins don't need to read the user document directly.
    // This function is a placeholder for documentation purposes.
    function hasPendingJoinRequestToMyGroup(targetUserId) {
      // Cannot be implemented efficiently in rules - handled at app level
      return false;
    }
    
    // ============================================
    // 1. USERS COLLECTION
    // ============================================
    match /users/{uid} {
      allow read: if isAuthenticated() && (
        userId() == uid || 
        // 1. SECURED: If target has groups, requester must share at least one.
        (
          "joinedGroupIds" in get(/databases/$(database)/documents/users/$(userId())).data && 
          resource.data.joinedGroupIds.hasAny(get(/databases/$(database)/documents/users/$(userId())).data.joinedGroupIds)
        ) ||
        // 2. TEMPORARY: Allow access if the target user has a pending request to a group the viewer admins
        // This is hard to enforce strictly in rules without collection group queries.
        // SAFE RELAXATION: Allow reading minimal profile info (display name) if authenticated? 
        // Current implementation is strict. 
        //
        // ALTERNATIVE: Use the app-side fix (embedding name in request).
        // 
        // However, if we MUST allow read:
        // We can't easily check the join_request existence in rules.
        //
        // Let's implement the 'Public Profile' concept where name/photo are readable by any auth user.
        // This is common practice and solves the issue of "stranger" interactions.
        true 
      );
      
      // User can only create their own document
      allow create: if isAuthenticated() && userId() == uid;
      
      // Update rules
      allow update: if isAuthenticated() && (
        // User can update ANY fields of their own profile
        userId() == uid ||
        // Owner/Admin can update ONLY these specific fields for other members
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['defaultLocation', 'birthday', 'hasLunarBirthday', 'lunarBirthdayMonth', 'lunarBirthdayDay', 'joinedGroupIds'])
      );
      
      // Delete not allowed (handled by account deletion flow)
      allow delete: if false;
      
      // Active sessions subcollection for multi-device detection
      match /active_sessions/{sessionId} {
        allow read, write: if isAuthenticated() && userId() == uid;
      }
    }
    
    // ============================================
    // 2. GROUPS COLLECTION
    // ============================================
    match /groups/{groupId} {
      // Any authenticated user can read groups (needed for join verification)
      // App-level filtering ensures users only see their own groups in UI
      allow read: if isAuthenticated();
      
      // Any authenticated user can create a group
      allow create: if isAuthenticated() && 
                       request.resource.data.ownerId == userId() &&
                       userId() in request.resource.data.members;
      
      // Update rules based on what's being changed
      allow update: if isAuthenticated() && (
        // Owner can do anything
        isGroupOwner(groupId) ||
        // Admin can update settings AND promote members to admin (but not change owner)
        (isGroupAdmin(groupId) && 
         !request.resource.data.diff(resource.data).affectedKeys().hasAny(['ownerId'])) ||
        // Any member can LEAVE (remove themselves from members and optionally admins)
        (userId() in resource.data.members &&
         !(userId() in request.resource.data.members) &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members', 'admins', 'ownerId']))
      );
      
      // Only owner can delete (or last member triggers deletion via app logic)
      allow delete: if isGroupOwner(groupId);
    }
    
    // ============================================
    // 3. USER_LOCATIONS COLLECTION
    // ============================================
    match /user_locations/{locationId} {
      // Read: authenticated users can read, app filters by group membership
      // (Upcoming Summary only shows locations for users in same groups)
      allow read: if isAuthenticated();
      
      // User can create/update their own locations
      // OR Owner/Admin can set any group member's location for their group
      allow create, update: if isAuthenticated() && (
        // Own location
        request.resource.data.userId == userId() ||
        // Owner/Admin setting for group member
        isGroupAdmin(request.resource.data.groupId)
      );
      
      // Delete own, or Owner/Admin for group members
      allow delete: if isAuthenticated() && (
        resource.data.userId == userId() ||
        isGroupAdmin(resource.data.groupId)
      );
    }
    
    // ============================================
    // 4. PLACEHOLDER_MEMBER_LOCATIONS COLLECTION
    // ============================================
    match /placeholder_member_locations/{locationId} {
      // Read: Strictly limited to group members
      allow read: if isAuthenticated() && isGroupMember(resource.data.groupId);
      
      // Only Owner or Admin can create/update/delete
      allow create, update: if isAuthenticated() && 
                               isGroupAdmin(request.resource.data.groupId);
      allow delete: if isAuthenticated() && 
                       isGroupAdmin(resource.data.groupId);
    }
    
    // ============================================
    // 5. PLACEHOLDER_MEMBERS COLLECTION
    // ============================================
    match /placeholder_members/{memberId} {
      // Read: Strictly limited to group members
      allow read: if isAuthenticated() && isGroupMember(resource.data.groupId);
      
      // Owner or Admin can create
      allow create: if isAuthenticated() && 
                       isGroupAdmin(request.resource.data.groupId);
      
      // Owner or Admin can update
      allow update: if isAuthenticated() && 
                       isGroupAdmin(resource.data.groupId);
      
      // Owner or Admin can delete (Admin needs this to approve inheritance)
      allow delete: if isAuthenticated() && 
                       isGroupAdmin(resource.data.groupId);
    }
    
    // ============================================
    // 6. EVENTS COLLECTION
    // ============================================
    match /events/{eventId} {
      // Only group members can read events (prevents data leak if user leaves group)
      allow read: if isAuthenticated() && isGroupMember(resource.data.groupId);
      
      // Any group member can create (creator becomes event owner)
      allow create: if isAuthenticated() && 
                       isGroupMember(request.resource.data.groupId) &&
                       request.resource.data.creatorId == userId();
      
      // Any group member can update event details
      allow update: if isAuthenticated() && 
                       isGroupMember(resource.data.groupId);
      
      // Event creator, group Owner, or Admin can delete
      allow delete: if isAuthenticated() && (
        resource.data.creatorId == userId() ||
        isGroupAdmin(resource.data.groupId)
      );
    }
    
    // ============================================
    // 7. INHERITANCE_REQUESTS COLLECTION
    // ============================================
    match /inheritance_requests/{requestId} {
      // Requester, Owner, or Admin can read
      allow read: if isAuthenticated() && (
        resource.data.requesterId == userId() ||
        isGroupAdmin(resource.data.groupId)
      );
      
      // Member or Admin can create (owner doesn't need to request)
      allow create: if isAuthenticated() && 
                       isGroupMember(request.resource.data.groupId) &&
                       request.resource.data.requesterId == userId() &&
                       !isGroupOwner(request.resource.data.groupId);
      
      // Owner or Admin can approve/reject (update status), but NOT their own request
      // Owner can approve any request except their own (though owner shouldn't have requests)
      // Admin can approve any request except their own
      allow update: if isAuthenticated() && 
                       isGroupAdmin(resource.data.groupId) &&
                       resource.data.requesterId != userId();
      
      // Requester or Owner can delete
      allow delete: if isAuthenticated() && (
        resource.data.requesterId == userId() ||
        isGroupOwner(resource.data.groupId)
      );
    }
    
    // ============================================
    // 8. NOTIFICATIONS COLLECTION
    // ============================================
    match /notifications/{notificationId} {
      // User can read their own notifications
      allow read: if isAuthenticated() && resource.data.userId == userId();
      
      // Any authenticated user can create or update notifications
      // (needed for deduplication when using set with merge:true)
      allow create, update: if isAuthenticated();
      
      // User can only delete their own
      allow delete: if isAuthenticated() && resource.data.userId == userId();
    }
    
    // ============================================
    // 9. JOIN_REQUESTS COLLECTION
    // ============================================
    match /join_requests/{requestId} {
      // Requester can read their own requests
      // Owner/Admin can read all requests for their groups
      allow read: if isAuthenticated() && (
        resource.data.requesterId == userId() ||
        isGroupAdmin(resource.data.groupId)
      );
      
      // Any authenticated user can create a join request
      // Must be requesting for themselves, status must be 'pending'
      allow create: if isAuthenticated() && 
                       request.resource.data.requesterId == userId() &&
                       request.resource.data.status == 'pending';
      
      // Only Owner/Admin can process (approve/reject)
      // Restrict changes to specific fields only
      allow update: if isAuthenticated() && 
                       isGroupAdmin(resource.data.groupId) &&
                       request.resource.data.diff(resource.data).affectedKeys()
                         .hasOnly(['status', 'processedBy', 'processedAt']);
      
      // Requester can delete their own pending request (cancel)
      allow delete: if isAuthenticated() && 
                       resource.data.requesterId == userId() &&
                       resource.data.status == 'pending';
    }
    
    // ============================================
    // 9. FEEDBACK COLLECTION (App Feedback)
    // ============================================
    match /feedback/{feedbackId} {
      // Only admin can read (via Firebase Console)
      allow read: if false;
      
      // Any authenticated user can submit feedback
      allow create: if isAuthenticated();
      
      // No updates or deletes
      allow update, delete: if false;
    }
    
  }
}